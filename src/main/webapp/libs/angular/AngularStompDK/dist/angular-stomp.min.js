/*! AngularStompDK v0.3.3 */
!function(){"use strict";var t=function(){function t(t,n){for(var i in n){var s=n[i];s.configurable=!0,s.value&&(s.writable=!0)}Object.defineProperties(t,n)}return function(n,i,s){return i&&t(n.prototype,i),s&&t(n,s),n}}(),n=function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")},i=function(){function i(){n(this,i),this.settings={}}return t(i,{credential:{value:function(t,n){return this.settings.login=t,this.settings.password=n,this}},url:{value:function(t){var n=function(n){return t.apply(this,arguments)};return n.toString=function(){return t.toString()},n}(function(t){return this.settings.url=t,this})},"class":{value:function(t){return this.settings["class"]=t,this}},setting:{value:function(t){return this.settings=t,this}},debug:{value:function(t){return this.settings.debug=t,this}},vhost:{value:function(t){return this.settings.vhost=t,this}},heartbeat:{value:function(){var t=void 0===arguments[0]?1e4:arguments[0],n=void 0===arguments[1]?1e4:arguments[1];return this.settings.heartbeat={outgoing:t,incoming:n},this}},$get:{value:["$q","$log","$rootScope","Stomp",function(t,n,i,e){return new s(this.settings,t,n,i,e)}]}}),i}(),s=function(){function i(t,s,e,o,r){n(this,i),this.settings=t,this.$q=s,this.$rootScope=o,this.$log=e,this.Stomp=r,this.connect()}return t(i,{connect:{value:function(){var t=this;return this.$setConnection(),this.stompClient.connect(this.settings.login,this.settings.password,function(){t.deferred.resolve(),t.$digestStompAction()},function(){t.deferred.reject(),t.$digestStompAction()},this.settings.vhost),this.promiseResult}},subscribe:{value:function(t,n,i,s){var e=this;return this.promiseResult.then(function(){e.$stompSubscribe(t,n,i||{}),e.unRegisterScopeOnDestroy(s,t)}),this}},subscribeTo:{value:function(t){return new e(this,t)}},unsubscribe:{value:function(t){var n=this;return this.promiseResult.then(function(){return n.$stompUnSubscribe(t)}),this}},send:{value:function(t,n,i){var s=this,e=this.$q.defer();return this.promiseResult.then(function(){s.stompClient.send(t,i||{},JSON.stringify(n)),e.resolve()}),e.promise}},disconnect:{value:function(){var t=this,n=this.$q.defer();return this.stompClient.disconnect(function(){n.resolve(),t.$digestStompAction()}),n.promise}},$stompSubscribe:{value:function(t,n,i){var s=this,e=s.stompClient.subscribe(t,function(){n.apply(s.stompClient,arguments),s.$digestStompAction()},i);this.connections.push({url:t,subscription:e})}},$stompUnSubscribe:{value:function(t){for(var n=!1,i=0,s=this.connections.length;s>i;i++)if(this.connections[i].url===t){n=i,this.connections[i].subscription.unsubscribe();break}n!==!1&&this.connections.splice(n,1)}},$digestStompAction:{value:function(){!this.$rootScope.$$phase&&this.$rootScope.$apply()}},$setConnection:{value:function(){this.stompClient=this.settings["class"]?this.Stomp.over(new this.settings["class"](this.settings.url)):this.Stomp.client(this.settings.url),this.stompClient.debug=this.settings.debug?this.$log.debug:angular.noop,angular.isDefined(this.settings.heartbeat)&&(this.stompClient.heartbeat.outgoing=this.settings.heartbeat.outgoing,this.stompClient.heartbeat.incoming=this.settings.heartbeat.incoming),this.connections=[],this.deferred=this.$q.defer(),this.promiseResult=this.deferred.promise}},unRegisterScopeOnDestroy:{value:function(t,n){var i=this;void 0!==t&&angular.isFunction(t.$on)&&t.$on("$destroy",function(){return i.unsubscribe(n)})}}}),i}(),e=function(){function i(t,s){n(this,i),this.ngStomp=t,this.topic=s,this.aCallback=angular.noop,this.headers={},this.scope={}}return t(i,{callback:{value:function(t){return this.aCallback=t,this}},withHeaders:{value:function(t){return this.headers=t,this}},bindTo:{value:function(t){return this.scope=t,this}},build:{value:function(){return this.ngStomp.subscribe(this.topic,this.aCallback,this.headers,this.scope)}},and:{value:function(){return this.build()}}}),i}();angular.module("AngularStompDK",[]).provider("ngstomp",i).constant("Stomp",window.Stomp)}();
//# sourceMappingURL=angular-stomp.min.js.map